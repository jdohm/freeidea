<html>

<head>
    <title>FreeIdea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/og.css" type="text/css" />
    <meta name="author" content="Jannis Dohm"><!-- based on openglobus.org -->
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="./media/favicon.svg">
</head>

<body>
    <div style="display: flex; flex-direction: column; align-content: space-between; flex-wrap: wrap; width: 100%; height: 100%;">
    <div id="earth" style="width:100%;height:100%"></div>
    <div id="idea" style="width:0%;height:100%;display:flex;justify-content:center;align-content: space-between; flex-wrap: wrap; overflow: auto;"></div><!-- flex-direction:column; -->
    </div>
    <script type="module">
        'use strict';

        import { Globe } from './src/og/Globe.js';
        import { GlobusTerrain } from './src/og/terrain/GlobusTerrain.js';
        import { XYZ } from './src/og/layer/XYZ.js';
        import { WMS } from './src/og/layer/WMS.js';
        import { Vector } from './src/og/layer/Vector.js';
        import { Vec2 } from './src/og/math/Vec2.js';
        import { Entity } from './src/og/entity/Entity.js';
        import { IdeaEntity } from './src/og/IdeaEntity.js';
        import { Idea } from './src/og/Idea.js';
        import { SideIdea } from './src/og/SideIdea.js';
        import { SideShowIdea } from './src/og/SideShowIdea.js';

     window.addEventListener("pageshow", (e) => {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var obj = JSON.parse(this.responseText);
                //Object.keys(this.responseText).forEach(key => {
                    //console.log(key, obj[key].lon);
                //});

                for (var key in obj) {
                    // skip loop if the property is from prototype
                    if (!obj.hasOwnProperty(key)) continue;

                    console.log('lon: ' + obj[key].lon + ' lat: ' + obj[key].lat + ' IdeaID: ' + obj[key].IdeaID);

                    var obj2 = pointLayer._entities.find(obj2 => obj2.properties.name == obj[key].IdeaID);
                    //if IdeaBeam with ID is missing create new IdeaBeam
                    if(obj2  == undefined) {
                        myCreateIdea(obj[key].lon, obj[key].lat, obj[key].IdeaID, obj[key].upvotes-obj[key].downvotes);
                        console.log("created Idea " + pointLayer._entities[key].properties.name);
                    } //else if necessary update size of existing idea beam
                    else if(obj2.billboard._height !== (obj[key].upvotes-obj[key].downvotes+50)) {
                        console.log("wrong size");
                        obj2.billboard._height = (obj[key].upvotes-obj[key].downvotes+50);
                        obj2.billboard.setHeight(obj[key].upvotes-obj[key].downvotes+50);
                    }
                }
            }
        };
        //xhttp.setRequestHeader("Accept", "application/json");
        //xhttp.setRequestHeader("Content-Type", "application/json");
        xhttp.open("GET", "getIdeas", true);
        xhttp.send();
     });

	   window.myCreateIdea = function myCreateIdea(lon, lat, id, votes){
         console.log("got " + votes + " votes");
         if(votes >= 0){
         pointLayer.add(new IdeaEntity({
             'name': id,
             'lonlat': [lon, lat],
             'billboard': {
                 'src': './media/pos.png',
                 'size': [24, votes+50],
                 'offset': [0, Math.round((votes+50)/2)]
             }
         }));
         }
         else if(votes > -48) {
             pointLayer.add(new IdeaEntity({
                 'name': id,
                 'lonlat': [lon, lat],
                 'billboard': {
                     'src': './media/neg.png',
                     'size': [24, votes+50],
                     'offset': [0, Math.round((votes+50)/2)]
                 }
             }));
         }
         else {
             //ignore vote, don't display
         }
	   };

        let pointLayer = new Vector("points", {
            'clampToGround': true,
            'async': false
        });

        let pickingObject = null;
        let startClick = new Vec2(),
            startPos;

        pointLayer.events.on("mouseenter", function (e) {
            e.renderer.handler.canvas.style.cursor = "pointer";
        });

        pointLayer.events.on("mouseleave", function (e) {
            e.renderer.handler.canvas.style.cursor = "default";
        });

        pointLayer.events.on("ldown", function (e) {
            startClick.set(e.x, e.y);
            pickingObject = e.pickingObject;
            startPos = e.pickingObject.layer.planet.getPixelFromCartesian(pickingObject.getCartesian());
        });

        pointLayer.events.on("lup", function (e) {
            pickingObject = null;
        });

        let osm = new XYZ("OSM", {
            'specular': [0.0003, 0.00012, 0.00001],
            'shininess': 20,
            'diffuse': [0.89, 0.9, 0.83],
            'isBaseLayer': true,
            'url': "//b.tile.openstreetmap.org/{z}/{x}/{y}.png",
            'visibility': true,
            'attribution': 'Data @ OpenStreetMap contributors, ODbL'
        });

        let globe = new Globe({
            "target": "earth",
            "name": "Earth",
            "terrain": new GlobusTerrain(),
            "layers": [osm, pointLayer]
        });

        globe.planet.renderer.events.on("mousemove", function (e) {
            if (pickingObject) {
                var d = new Vec2(e.x, e.y).sub(startClick);
                var endPos = startPos.add(d);
                var coords = this.getCartesianFromPixelTerrain(endPos);
                if (coords) {
                    pickingObject.setCartesian3v(coords);
                }
            }
        }, globe.planet);

        let myIdea = new Idea({
            planet: globe.planet,
            offset: [0, -235],
            visibility: false
        });

     let mySideIdea = new SideIdea({
         planet: globe.planet,
     });

     let mySideShowIdea = new SideShowIdea({
         planet: globe.planet,
     });

	function myFunction(){
            myIdea.setVisibility(true);
	}

	function myHideFunction(){
            myIdea.setVisibility(false);
	}

	   function myCreateIdeaFunction(ll){
            pointLayer.add(new Entity({
                'name': 'New Marker',
                'lonlat': ll,
                'billboard': {
                    'src': './media/pos.png',
                    'size': [12, 48],
                    'offset': [0, 24]
                }
            }));
	}


     //Zoom in (deativate for testing, to prevent long loading times)
        //globe.planet.viewExtentArr([8.08, 46.72, 8.31, 46.75]);

        globe.planet.renderer.events.on("lclick", function (e) {
            let groundPos = globe.planet.getCartesianFromMouseTerrain();
            var ll = globe.planet.getLonLatFromPixelTerrain(e, true);
            if (pickingObject) {
                //e.pickingObject.showIdea(globe.planet, e.pickingObject.properties.name);
			          mySideShowIdea.setFunction(ll);
                mySideShowIdea.show(e.pickingObject.properties.name);
	          }
	          else if(groundPos !== null && ll !== null){//New Idea
			          mySideIdea.setFunction(myCreateIdea, ll);
                mySideIdea.show();
	    }

        });
     var _coordX;
     var _coordY;
     globe.planet.renderer.events.on("touchstart", function (e) {
         _coordX = e.x;
         _coordY = e.y;
     });
     globe.planet.renderer.events.on("touchend", function (e) {
         if(Math.hypot(e.x - _coordX, e.y -  _coordY) <= 3){
         let groundPos = globe.planet.getCartesianFromMouseTerrain();
         var ll = globe.planet.getLonLatFromPixelTerrain(e, true);
         var name;
         try{name = e.pickingObject.properties.name;}
         catch(err){console.log("name not found")};
         if (name) {
             alert(window.screen.width + "x" + window.screen.height + " und " + document.documentElement.clientWidth + "x" + document.documentElement.clientHeight);
//             window.open("mobileShowIdea?IdeaID=" + name, "_top");
	       }
	       else if(groundPos !== null && ll !== null){//New Idea
			       mySideIdea.setFunction(myCreateIdea, ll);
             mySideIdea.show();
	       }
         }
     });

        pointLayer.events.on("rclick", function(e){
            //e.pickingObject.remove();
        });


        window.p = pointLayer;



     //function to change height of idea after vote
     //could be improved to also change the color at threshold
        window.myUpdateIdeaHeight = function myUpdateIdeaHeight(IdeaID, vote){
            var obj2 = pointLayer._entities.find(obj2 => obj2.properties.name == IdeaID);
            obj2.billboard._height += vote;
            obj2.billboard._offset.y = Math.round((vote+50)/2);
            obj2.billboard.setOffset(0,Math.round((vote+50)/2),0);
            obj2.billboard.setHeight(obj2.billboard._height);
        };
    </script>
</body>

</html>
